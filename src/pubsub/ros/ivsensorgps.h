// Generated by gencpp from file gps_imu/ivsensorgps.msg
// DO NOT EDIT!


#ifndef GPS_IMU_MESSAGE_IVSENSORGPS_H
#define GPS_IMU_MESSAGE_IVSENSORGPS_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace gps_imu
{
template <class ContainerAllocator>
struct ivsensorgps_
{
  typedef ivsensorgps_<ContainerAllocator> Type;

  ivsensorgps_()
    : header()
    , lon(0.0)
    , lat(0.0)
    , height(0.0)
    , mode(0) //解的类型
    , heading(0.0)
    , velocity(0.0)
    , status()
    , satenum(0)// 卫星数
    , isvalid(0)
    , acceleration(0.0)
    , pitch(0.0)
    , roll(0.0)
    , angx(0.0)
    , angy(0.0)
    , yaw(0.0)
    , accx(0.0)
    , accy(0.0)
    , accz(0.0)
    , msgflag()
    , gpsweek(0.0)
    , gpstime(0.0)  {
    }
  ivsensorgps_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , lon(0.0)
    , lat(0.0)
    , height(0.0)
    , mode(0)
    , heading(0.0)
    , velocity(0.0)
    , status(_alloc)
    , satenum(0)
    , isvalid(0)
    , acceleration(0.0)
    , pitch(0.0)
    , roll(0.0)
    , angx(0.0)
    , angy(0.0)
    , yaw(0.0)
    , accx(0.0)
    , accy(0.0)
    , accz(0.0)
    , msgflag(_alloc)
    , gpsweek(0.0)
    , gpstime(0.0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef double _lon_type;
  _lon_type lon;

   typedef double _lat_type;
  _lat_type lat;

   typedef double _height_type;
  _height_type height;

   typedef uint8_t _mode_type;
  _mode_type mode;

   typedef double _heading_type;
  _heading_type heading;

   typedef double _velocity_type;
  _velocity_type velocity;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _status_type;
  _status_type status;

   typedef int32_t _satenum_type;
  _satenum_type satenum;

   typedef uint8_t _isvalid_type;
  _isvalid_type isvalid;

   typedef double _acceleration_type;
  _acceleration_type acceleration;

   typedef double _pitch_type;
  _pitch_type pitch;

   typedef double _roll_type;
  _roll_type roll;

   typedef double _angx_type;
  _angx_type angx;

   typedef double _angy_type;
  _angy_type angy;

   typedef double _yaw_type;
  _yaw_type yaw;

   typedef double _accx_type;
  _accx_type accx;

   typedef double _accy_type;
  _accy_type accy;

   typedef double _accz_type;
  _accz_type accz;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _msgflag_type;
  _msgflag_type msgflag;

   typedef double _gpsweek_type;
  _gpsweek_type gpsweek;

   typedef double _gpstime_type;
  _gpstime_type gpstime;





  typedef boost::shared_ptr< ::gps_imu::ivsensorgps_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::gps_imu::ivsensorgps_<ContainerAllocator> const> ConstPtr;

}; // struct ivsensorgps_

typedef ::gps_imu::ivsensorgps_<std::allocator<void> > ivsensorgps;

typedef boost::shared_ptr< ::gps_imu::ivsensorgps > ivsensorgpsPtr;
typedef boost::shared_ptr< ::gps_imu::ivsensorgps const> ivsensorgpsConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::gps_imu::ivsensorgps_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::gps_imu::ivsensorgps_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::gps_imu::ivsensorgps_<ContainerAllocator1> & lhs, const ::gps_imu::ivsensorgps_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.lon == rhs.lon &&
    lhs.lat == rhs.lat &&
    lhs.height == rhs.height &&
    lhs.mode == rhs.mode &&
    lhs.heading == rhs.heading &&
    lhs.velocity == rhs.velocity &&
    lhs.status == rhs.status &&
    lhs.satenum == rhs.satenum &&
    lhs.isvalid == rhs.isvalid &&
    lhs.acceleration == rhs.acceleration &&
    lhs.pitch == rhs.pitch &&
    lhs.roll == rhs.roll &&
    lhs.angx == rhs.angx &&
    lhs.angy == rhs.angy &&
    lhs.yaw == rhs.yaw &&
    lhs.accx == rhs.accx &&
    lhs.accy == rhs.accy &&
    lhs.accz == rhs.accz &&
    lhs.msgflag == rhs.msgflag &&
    lhs.gpsweek == rhs.gpsweek &&
    lhs.gpstime == rhs.gpstime;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::gps_imu::ivsensorgps_<ContainerAllocator1> & lhs, const ::gps_imu::ivsensorgps_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace gps_imu

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::gps_imu::ivsensorgps_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::gps_imu::ivsensorgps_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::gps_imu::ivsensorgps_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::gps_imu::ivsensorgps_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::gps_imu::ivsensorgps_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::gps_imu::ivsensorgps_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::gps_imu::ivsensorgps_<ContainerAllocator> >
{
  static const char* value()
  {
    return "2ba7b03ee321b2769da86b5de8256f46";
  }

  static const char* value(const ::gps_imu::ivsensorgps_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x2ba7b03ee321b276ULL;
  static const uint64_t static_value2 = 0x9da86b5de8256f46ULL;
};

template<class ContainerAllocator>
struct DataType< ::gps_imu::ivsensorgps_<ContainerAllocator> >
{
  static const char* value()
  {
    return "gps_imu/ivsensorgps";
  }

  static const char* value(const ::gps_imu::ivsensorgps_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::gps_imu::ivsensorgps_<ContainerAllocator> >
{
  static const char* value()
  {
    return "std_msgs/Header header\n"
"float64 lon\n"
"float64 lat\n"
"float64 height\n"
"uint8 mode\n"
"float64 heading\n"
"float64 velocity\n"
"string status\n"
"int32 satenum\n"
"uint8 isvalid\n"
"float64 acceleration\n"
"float64 pitch\n"
"float64 roll\n"
"float64 angx\n"
"float64 angy\n"
"float64 yaw\n"
"float64 accx\n"
"float64 accy\n"
"float64 accz\n"
"string msgflag\n"
"float64 gpsweek\n"
"float64 gpstime\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::gps_imu::ivsensorgps_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::gps_imu::ivsensorgps_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.lon);
      stream.next(m.lat);
      stream.next(m.height);
      stream.next(m.mode);
      stream.next(m.heading);
      stream.next(m.velocity);
      stream.next(m.status);
      stream.next(m.satenum);
      stream.next(m.isvalid);
      stream.next(m.acceleration);
      stream.next(m.pitch);
      stream.next(m.roll);
      stream.next(m.angx);
      stream.next(m.angy);
      stream.next(m.yaw);
      stream.next(m.accx);
      stream.next(m.accy);
      stream.next(m.accz);
      stream.next(m.msgflag);
      stream.next(m.gpsweek);
      stream.next(m.gpstime);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct ivsensorgps_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::gps_imu::ivsensorgps_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::gps_imu::ivsensorgps_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "lon: ";
    Printer<double>::stream(s, indent + "  ", v.lon);
    s << indent << "lat: ";
    Printer<double>::stream(s, indent + "  ", v.lat);
    s << indent << "height: ";
    Printer<double>::stream(s, indent + "  ", v.height);
    s << indent << "mode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.mode);
    s << indent << "heading: ";
    Printer<double>::stream(s, indent + "  ", v.heading);
    s << indent << "velocity: ";
    Printer<double>::stream(s, indent + "  ", v.velocity);
    s << indent << "status: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.status);
    s << indent << "satenum: ";
    Printer<int32_t>::stream(s, indent + "  ", v.satenum);
    s << indent << "isvalid: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.isvalid);
    s << indent << "acceleration: ";
    Printer<double>::stream(s, indent + "  ", v.acceleration);
    s << indent << "pitch: ";
    Printer<double>::stream(s, indent + "  ", v.pitch);
    s << indent << "roll: ";
    Printer<double>::stream(s, indent + "  ", v.roll);
    s << indent << "angx: ";
    Printer<double>::stream(s, indent + "  ", v.angx);
    s << indent << "angy: ";
    Printer<double>::stream(s, indent + "  ", v.angy);
    s << indent << "yaw: ";
    Printer<double>::stream(s, indent + "  ", v.yaw);
    s << indent << "accx: ";
    Printer<double>::stream(s, indent + "  ", v.accx);
    s << indent << "accy: ";
    Printer<double>::stream(s, indent + "  ", v.accy);
    s << indent << "accz: ";
    Printer<double>::stream(s, indent + "  ", v.accz);
    s << indent << "msgflag: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.msgflag);
    s << indent << "gpsweek: ";
    Printer<double>::stream(s, indent + "  ", v.gpsweek);
    s << indent << "gpstime: ";
    Printer<double>::stream(s, indent + "  ", v.gpstime);
  }
};

} // namespace message_operations
} // namespace ros

#endif // GPS_IMU_MESSAGE_IVSENSORGPS_H
