/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2020-2021. All rights reserved.
 * Generated by VRTF CM-Generator
 */

#ifndef ARA_RDETECT_IMPL_TYPE_RADARDETECT_H
#define ARA_RDETECT_IMPL_TYPE_RADARDETECT_H
#include <cfloat>
#include <cmath>
#include "impl_type_uint8.h"
#include "impl_type_float.h"

namespace ara {
namespace rdetect {
struct RadarDetect {
    ::UInt8 id;
    ::UInt8 idPair;
    ::UInt8 coordinate;
    ::Float x;
    ::Float y;
    ::Float z;
    ::Float vx;
    ::Float vy;
    ::Float rcs;
    ::Float snr;
    ::Float xRms;
    ::Float yRms;
    ::Float zRms;
    ::Float vxRms;
    ::Float vyRms;
    ::Float xQuality;
    ::Float yQuality;
    ::Float zQuality;
    ::Float vxQuality;
    ::Float vyQuality;
    ::UInt8 existProbability;
    ::UInt8 falseProbability;
    ::UInt8 movProperty;
    ::UInt8 invalidState;
    ::UInt8 ambiguity;

    static bool IsPlane()
    {
        return true;
    }


    using IsEnumerableTag = void;
    template<typename F>
    void enumerate(F& fun)
    {
        fun(id);
        fun(idPair);
        fun(coordinate);
        fun(x);
        fun(y);
        fun(z);
        fun(vx);
        fun(vy);
        fun(rcs);
        fun(snr);
        fun(xRms);
        fun(yRms);
        fun(zRms);
        fun(vxRms);
        fun(vyRms);
        fun(xQuality);
        fun(yQuality);
        fun(zQuality);
        fun(vxQuality);
        fun(vyQuality);
        fun(existProbability);
        fun(falseProbability);
        fun(movProperty);
        fun(invalidState);
        fun(ambiguity);
    }

    template<typename F>
    void enumerate(F& fun) const
    {
        fun(id);
        fun(idPair);
        fun(coordinate);
        fun(x);
        fun(y);
        fun(z);
        fun(vx);
        fun(vy);
        fun(rcs);
        fun(snr);
        fun(xRms);
        fun(yRms);
        fun(zRms);
        fun(vxRms);
        fun(vyRms);
        fun(xQuality);
        fun(yQuality);
        fun(zQuality);
        fun(vxQuality);
        fun(vyQuality);
        fun(existProbability);
        fun(falseProbability);
        fun(movProperty);
        fun(invalidState);
        fun(ambiguity);
    }

    bool operator == (const ::ara::rdetect::RadarDetect& t) const
    {
        return (id == t.id) && (idPair == t.idPair) && (coordinate == t.coordinate) && (fabs(x - t.x) < FLT_EPSILON) && (fabs(y - t.y) < FLT_EPSILON) && (fabs(z - t.z) < FLT_EPSILON) && (fabs(vx - t.vx) < FLT_EPSILON) && (fabs(vy - t.vy) < FLT_EPSILON) && (fabs(rcs - t.rcs) < FLT_EPSILON) && (fabs(snr - t.snr) < FLT_EPSILON) && (fabs(xRms - t.xRms) < FLT_EPSILON) && (fabs(yRms - t.yRms) < FLT_EPSILON) && (fabs(zRms - t.zRms) < FLT_EPSILON) && (fabs(vxRms - t.vxRms) < FLT_EPSILON) && (fabs(vyRms - t.vyRms) < FLT_EPSILON) && (fabs(xQuality - t.xQuality) < FLT_EPSILON) && (fabs(yQuality - t.yQuality) < FLT_EPSILON) && (fabs(zQuality - t.zQuality) < FLT_EPSILON) && (fabs(vxQuality - t.vxQuality) < FLT_EPSILON) && (fabs(vyQuality - t.vyQuality) < FLT_EPSILON) && (existProbability == t.existProbability) && (falseProbability == t.falseProbability) && (movProperty == t.movProperty) && (invalidState == t.invalidState) && (ambiguity == t.ambiguity);
    }
};
} // namespace rdetect
} // namespace ara


#endif // ARA_RDETECT_IMPL_TYPE_RADARDETECT_H
