/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2020-2021. All rights reserved.
 * Generated by VRTF CM-Generator
 */

#ifndef ARA_CHASSISGACA13_IMPL_TYPE_BCS8A_H
#define ARA_CHASSISGACA13_IMPL_TYPE_BCS8A_H
#include <cfloat>
#include <cmath>
#include "impl_type_uint8.h"
#include "impl_type_float.h"
#include "impl_type_uint16.h"

namespace ara {
namespace chassisgaca13 {
struct Bcs8A {
    ::UInt8 bcsMasterCylinderPrOffsetVd;
    ::UInt8 bcsMasterCylinderPrVd;
    ::UInt8 bcsBrakeOverHeat;
    ::UInt8 bcsNoBrakeForce;
    ::Float bcsMasterCylinderPr;
    ::UInt8 bcs8AMsgCounter;
    ::UInt8 bcsAbaavailable;
    ::UInt8 bcsAbaactive;
    ::Float bcsMasterCylinderPrOffset;
    ::UInt8 bcsCddavailable;
    ::UInt8 bcsCddactive;
    ::UInt8 bcsAwbavailable;
    ::UInt8 bcsAwbactive;
    ::UInt8 bcsAebavailable;
    ::UInt8 bcsAebactive;
    ::UInt8 bcsAbpavailable;
    ::UInt8 bcsAbpactive;
    ::UInt8 bcsCddfail;
    ::UInt8 bcsVehicleStandStillSt;
    ::UInt8 bcsQdcacc;
    ::UInt16 bcs8AChecksum;

    static bool IsPlane()
    {
        return true;
    }


    using IsEnumerableTag = void;
    template<typename F>
    void enumerate(F& fun)
    {
        fun(bcsMasterCylinderPrOffsetVd);
        fun(bcsMasterCylinderPrVd);
        fun(bcsBrakeOverHeat);
        fun(bcsNoBrakeForce);
        fun(bcsMasterCylinderPr);
        fun(bcs8AMsgCounter);
        fun(bcsAbaavailable);
        fun(bcsAbaactive);
        fun(bcsMasterCylinderPrOffset);
        fun(bcsCddavailable);
        fun(bcsCddactive);
        fun(bcsAwbavailable);
        fun(bcsAwbactive);
        fun(bcsAebavailable);
        fun(bcsAebactive);
        fun(bcsAbpavailable);
        fun(bcsAbpactive);
        fun(bcsCddfail);
        fun(bcsVehicleStandStillSt);
        fun(bcsQdcacc);
        fun(bcs8AChecksum);
    }

    template<typename F>
    void enumerate(F& fun) const
    {
        fun(bcsMasterCylinderPrOffsetVd);
        fun(bcsMasterCylinderPrVd);
        fun(bcsBrakeOverHeat);
        fun(bcsNoBrakeForce);
        fun(bcsMasterCylinderPr);
        fun(bcs8AMsgCounter);
        fun(bcsAbaavailable);
        fun(bcsAbaactive);
        fun(bcsMasterCylinderPrOffset);
        fun(bcsCddavailable);
        fun(bcsCddactive);
        fun(bcsAwbavailable);
        fun(bcsAwbactive);
        fun(bcsAebavailable);
        fun(bcsAebactive);
        fun(bcsAbpavailable);
        fun(bcsAbpactive);
        fun(bcsCddfail);
        fun(bcsVehicleStandStillSt);
        fun(bcsQdcacc);
        fun(bcs8AChecksum);
    }

    bool operator == (const ::ara::chassisgaca13::Bcs8A& t) const
    {
        return (bcsMasterCylinderPrOffsetVd == t.bcsMasterCylinderPrOffsetVd) && (bcsMasterCylinderPrVd == t.bcsMasterCylinderPrVd) && (bcsBrakeOverHeat == t.bcsBrakeOverHeat) && (bcsNoBrakeForce == t.bcsNoBrakeForce) && (fabs(bcsMasterCylinderPr - t.bcsMasterCylinderPr) < FLT_EPSILON) && (bcs8AMsgCounter == t.bcs8AMsgCounter) && (bcsAbaavailable == t.bcsAbaavailable) && (bcsAbaactive == t.bcsAbaactive) && (fabs(bcsMasterCylinderPrOffset - t.bcsMasterCylinderPrOffset) < FLT_EPSILON) && (bcsCddavailable == t.bcsCddavailable) && (bcsCddactive == t.bcsCddactive) && (bcsAwbavailable == t.bcsAwbavailable) && (bcsAwbactive == t.bcsAwbactive) && (bcsAebavailable == t.bcsAebavailable) && (bcsAebactive == t.bcsAebactive) && (bcsAbpavailable == t.bcsAbpavailable) && (bcsAbpactive == t.bcsAbpactive) && (bcsCddfail == t.bcsCddfail) && (bcsVehicleStandStillSt == t.bcsVehicleStandStillSt) && (bcsQdcacc == t.bcsQdcacc) && (bcs8AChecksum == t.bcs8AChecksum);
    }
};
} // namespace chassisgaca13
} // namespace ara


#endif // ARA_CHASSISGACA13_IMPL_TYPE_BCS8A_H
