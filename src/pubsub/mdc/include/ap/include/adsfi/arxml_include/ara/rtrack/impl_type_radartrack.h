/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2020-2021. All rights reserved.
 * Generated by VRTF CM-Generator
 */

#ifndef ARA_RTRACK_IMPL_TYPE_RADARTRACK_H
#define ARA_RTRACK_IMPL_TYPE_RADARTRACK_H
#include <cfloat>
#include <cmath>
#include "impl_type_uint8.h"
#include "impl_type_float.h"

namespace ara {
namespace rtrack {
struct RadarTrack {
    ::UInt8 id;
    ::UInt8 idState;
    ::Float lifetime;
    ::Float x;
    ::Float y;
    ::Float z;
    ::Float vx;
    ::Float vy;
    ::Float ax;
    ::Float ay;
    ::Float rcs;
    ::Float snr;
    ::Float xRms;
    ::Float yRms;
    ::Float zRms;
    ::Float vxRms;
    ::Float vyRms;
    ::Float axRms;
    ::Float ayRms;
    ::Float orientation;
    ::Float orientRms;
    ::Float yawRate;
    ::Float length;
    ::Float width;
    ::Float height;
    ::Float yawRateRms;
    ::Float lengthRms;
    ::Float widthRms;
    ::Float heightRms;
    ::Float xQuality;
    ::Float yQuality;
    ::Float zQuality;
    ::Float vxQuality;
    ::Float vyQuality;
    ::Float axQuality;
    ::Float ayQuality;
    ::Float orientationQuality;
    ::Float yawRateQuality;
    ::Float lengthQuality;
    ::Float widthQuality;
    ::Float heightQuality;
    ::Float underpassProbability;
    ::Float overpassProbability;
    ::UInt8 existProbability;
    ::UInt8 movProperty;
    ::UInt8 trackState;
    ::UInt8 trackType;

    static bool IsPlane()
    {
        return true;
    }


    using IsEnumerableTag = void;
    template<typename F>
    void enumerate(F& fun)
    {
        fun(id);
        fun(idState);
        fun(lifetime);
        fun(x);
        fun(y);
        fun(z);
        fun(vx);
        fun(vy);
        fun(ax);
        fun(ay);
        fun(rcs);
        fun(snr);
        fun(xRms);
        fun(yRms);
        fun(zRms);
        fun(vxRms);
        fun(vyRms);
        fun(axRms);
        fun(ayRms);
        fun(orientation);
        fun(orientRms);
        fun(yawRate);
        fun(length);
        fun(width);
        fun(height);
        fun(yawRateRms);
        fun(lengthRms);
        fun(widthRms);
        fun(heightRms);
        fun(xQuality);
        fun(yQuality);
        fun(zQuality);
        fun(vxQuality);
        fun(vyQuality);
        fun(axQuality);
        fun(ayQuality);
        fun(orientationQuality);
        fun(yawRateQuality);
        fun(lengthQuality);
        fun(widthQuality);
        fun(heightQuality);
        fun(underpassProbability);
        fun(overpassProbability);
        fun(existProbability);
        fun(movProperty);
        fun(trackState);
        fun(trackType);
    }

    template<typename F>
    void enumerate(F& fun) const
    {
        fun(id);
        fun(idState);
        fun(lifetime);
        fun(x);
        fun(y);
        fun(z);
        fun(vx);
        fun(vy);
        fun(ax);
        fun(ay);
        fun(rcs);
        fun(snr);
        fun(xRms);
        fun(yRms);
        fun(zRms);
        fun(vxRms);
        fun(vyRms);
        fun(axRms);
        fun(ayRms);
        fun(orientation);
        fun(orientRms);
        fun(yawRate);
        fun(length);
        fun(width);
        fun(height);
        fun(yawRateRms);
        fun(lengthRms);
        fun(widthRms);
        fun(heightRms);
        fun(xQuality);
        fun(yQuality);
        fun(zQuality);
        fun(vxQuality);
        fun(vyQuality);
        fun(axQuality);
        fun(ayQuality);
        fun(orientationQuality);
        fun(yawRateQuality);
        fun(lengthQuality);
        fun(widthQuality);
        fun(heightQuality);
        fun(underpassProbability);
        fun(overpassProbability);
        fun(existProbability);
        fun(movProperty);
        fun(trackState);
        fun(trackType);
    }

    bool operator == (const ::ara::rtrack::RadarTrack& t) const
    {
        return (id == t.id) && (idState == t.idState) && (fabs(lifetime - t.lifetime) < FLT_EPSILON) && (fabs(x - t.x) < FLT_EPSILON) && (fabs(y - t.y) < FLT_EPSILON) && (fabs(z - t.z) < FLT_EPSILON) && (fabs(vx - t.vx) < FLT_EPSILON) && (fabs(vy - t.vy) < FLT_EPSILON) && (fabs(ax - t.ax) < FLT_EPSILON) && (fabs(ay - t.ay) < FLT_EPSILON) && (fabs(rcs - t.rcs) < FLT_EPSILON) && (fabs(snr - t.snr) < FLT_EPSILON) && (fabs(xRms - t.xRms) < FLT_EPSILON) && (fabs(yRms - t.yRms) < FLT_EPSILON) && (fabs(zRms - t.zRms) < FLT_EPSILON) && (fabs(vxRms - t.vxRms) < FLT_EPSILON) && (fabs(vyRms - t.vyRms) < FLT_EPSILON) && (fabs(axRms - t.axRms) < FLT_EPSILON) && (fabs(ayRms - t.ayRms) < FLT_EPSILON) && (fabs(orientation - t.orientation) < FLT_EPSILON) && (fabs(orientRms - t.orientRms) < FLT_EPSILON) && (fabs(yawRate - t.yawRate) < FLT_EPSILON) && (fabs(length - t.length) < FLT_EPSILON) && (fabs(width - t.width) < FLT_EPSILON) && (fabs(height - t.height) < FLT_EPSILON) && (fabs(yawRateRms - t.yawRateRms) < FLT_EPSILON) && (fabs(lengthRms - t.lengthRms) < FLT_EPSILON) && (fabs(widthRms - t.widthRms) < FLT_EPSILON) && (fabs(heightRms - t.heightRms) < FLT_EPSILON) && (fabs(xQuality - t.xQuality) < FLT_EPSILON) && (fabs(yQuality - t.yQuality) < FLT_EPSILON) && (fabs(zQuality - t.zQuality) < FLT_EPSILON) && (fabs(vxQuality - t.vxQuality) < FLT_EPSILON) && (fabs(vyQuality - t.vyQuality) < FLT_EPSILON) && (fabs(axQuality - t.axQuality) < FLT_EPSILON) && (fabs(ayQuality - t.ayQuality) < FLT_EPSILON) && (fabs(orientationQuality - t.orientationQuality) < FLT_EPSILON) && (fabs(yawRateQuality - t.yawRateQuality) < FLT_EPSILON) && (fabs(lengthQuality - t.lengthQuality) < FLT_EPSILON) && (fabs(widthQuality - t.widthQuality) < FLT_EPSILON) && (fabs(heightQuality - t.heightQuality) < FLT_EPSILON) && (fabs(underpassProbability - t.underpassProbability) < FLT_EPSILON) && (fabs(overpassProbability - t.overpassProbability) < FLT_EPSILON) && (existProbability == t.existProbability) && (movProperty == t.movProperty) && (trackState == t.trackState) && (trackType == t.trackType);
    }
};
} // namespace rtrack
} // namespace ara


#endif // ARA_RTRACK_IMPL_TYPE_RADARTRACK_H
