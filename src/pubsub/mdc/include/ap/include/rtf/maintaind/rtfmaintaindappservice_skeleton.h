/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2020-2020. All rights reserved.
 * Generated by VRTF CM-Generator
 */

#ifndef RTF_MAINTAIND_RTFMAINTAINDAPPSERVICE_SKELETON_H
#define RTF_MAINTAIND_RTFMAINTAINDAPPSERVICE_SKELETON_H

#include "ara/com/internal/skeleton/skeleton_adapter.h"
#include "ara/com/internal/skeleton/event_adapter.h"
#include "ara/com/internal/skeleton/field_adapter.h"
#include "ara/com/internal/skeleton/method_adapter.h"
#include "rtf/maintaind/rtfmaintaindappservice_common.h"
#include <cstdint>

namespace rtf {
namespace maintaind {
namespace skeleton {
namespace events {
    using SwitchApplicationLatency = ara::com::internal::skeleton::event::EventAdapter<::rtf::maintaind::LatencySwitch>;
    // SwitchApplicationLatency_event_hash
    static constexpr ara::com::internal::EntityId SwitchApplicationLatencyId = 30161;
}

namespace methods {
    using NotifyLatencyModeHandle = ara::com::internal::skeleton::method::MethodAdapter;
    using NotifyLatencyResultHandle = ara::com::internal::skeleton::method::MethodAdapter;
    using RegisterEventInfoHandle = ara::com::internal::skeleton::method::MethodAdapter;
    using RegisterFieldInfoHandle = ara::com::internal::skeleton::method::MethodAdapter;
    using RegisterMethodInfoHandle = ara::com::internal::skeleton::method::MethodAdapter;
    using RegisterNodeInfoHandle = ara::com::internal::skeleton::method::MethodAdapter;
    using UnregisterEventInfoHandle = ara::com::internal::skeleton::method::MethodAdapter;
    using UnregisterFieldInfoHandle = ara::com::internal::skeleton::method::MethodAdapter;
    using UnregisterMethodInfoHandle = ara::com::internal::skeleton::method::MethodAdapter;
    static constexpr ara::com::internal::EntityId NotifyLatencyModeId = 33436; // NotifyLatencyMode_method_hash
    static constexpr ara::com::internal::EntityId NotifyLatencyResultId = 54641; // NotifyLatencyResult_method_hash
    static constexpr ara::com::internal::EntityId RegisterEventInfoId = 60620; // RegisterEventInfo_method_hash
    static constexpr ara::com::internal::EntityId RegisterFieldInfoId = 62836; // RegisterFieldInfo_method_hash
    static constexpr ara::com::internal::EntityId RegisterMethodInfoId = 54288; // RegisterMethodInfo_method_hash
    static constexpr ara::com::internal::EntityId RegisterNodeInfoId = 52436; // RegisterNodeInfo_method_hash
    static constexpr ara::com::internal::EntityId UnregisterEventInfoId = 26369; // UnregisterEventInfo_method_hash
    static constexpr ara::com::internal::EntityId UnregisterFieldInfoId = 62056; // UnregisterFieldInfo_method_hash
    static constexpr ara::com::internal::EntityId UnregisterMethodInfoId = 58344; // UnregisterMethodInfo_method_hash
}

namespace fields {
}

class RTFMaintaindAppServiceSkeleton {
private:
    std::unique_ptr<ara::com::internal::skeleton::SkeletonAdapter> skeletonAdapter;
    void ConstructSkeleton(ara::com::MethodCallProcessingMode mode)
    {
        bool result = true;
        if (mode == ara::com::MethodCallProcessingMode::kEvent) {
            std::uint16_t threadNum = 9;
            std::uint16_t taskNum = 1024;
            result = result && skeletonAdapter->SetMethodThreadNumber(
                skeletonAdapter->GetMethodThreadNumber(threadNum), taskNum);
        }
        result = result && ((skeletonAdapter->InitializeEvent(SwitchApplicationLatency)).HasValue());
        result = result && ((skeletonAdapter->InitializeMethod<ara::core::Future<NotifyLatencyModeOutput>>(
	        methods::NotifyLatencyModeId)).HasValue());
        result = result && ((skeletonAdapter->InitializeMethod<ara::core::Future<NotifyLatencyResultOutput>>(
	        methods::NotifyLatencyResultId)).HasValue());
        result = result && ((skeletonAdapter->InitializeMethod<ara::core::Future<RegisterEventInfoOutput>>(
	        methods::RegisterEventInfoId)).HasValue());
        result = result && ((skeletonAdapter->InitializeMethod<ara::core::Future<RegisterFieldInfoOutput>>(
	        methods::RegisterFieldInfoId)).HasValue());
        result = result && ((skeletonAdapter->InitializeMethod<ara::core::Future<RegisterMethodInfoOutput>>(
	        methods::RegisterMethodInfoId)).HasValue());
        result = result && ((skeletonAdapter->InitializeMethod<ara::core::Future<RegisterNodeInfoOutput>>(
	        methods::RegisterNodeInfoId)).HasValue());
        result = result && ((skeletonAdapter->InitializeMethod<ara::core::Future<UnregisterEventInfoOutput>>(
	        methods::UnregisterEventInfoId)).HasValue());
        result = result && ((skeletonAdapter->InitializeMethod<ara::core::Future<UnregisterFieldInfoOutput>>(
	        methods::UnregisterFieldInfoId)).HasValue());
        result = result && ((skeletonAdapter->InitializeMethod<ara::core::Future<UnregisterMethodInfoOutput>>(
	        methods::UnregisterMethodInfoId)).HasValue());
        if (result == false) {
#ifndef NOT_SUPPORT_EXCEPTIONS
            ara::core::ErrorCode errorcode(ara::com::ComErrc::kNetworkBindingFailure);
            throw ara::com::ComException(std::move(errorcode));
#else
            std::cout << "Error: Not support exception, create skeleton failed!"<< std::endl;
#endif
        }
    }
public:

    struct NotifyLatencyModeOutput {
        ::rtf::maintaind::ReturnCode result;

        static bool IsPlane()
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun)
        {
            fun(result);
        }

        template<typename F>
        void enumerate(F& fun) const
        {
            fun(result);
        }

        bool operator == (const NotifyLatencyModeOutput& t) const
        {
            return (result == t.result);
        }
    };

    struct NotifyLatencyResultOutput {
        ::rtf::maintaind::ReturnCode result;

        static bool IsPlane()
        {
            return true;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun)
        {
            fun(result);
        }

        template<typename F>
        void enumerate(F& fun) const
        {
            fun(result);
        }

        bool operator == (const NotifyLatencyResultOutput& t) const
        {
            return (result == t.result);
        }
    };

    struct RegisterEventInfoOutput {
        ::rtf::maintaind::ReturnCode result;

        static bool IsPlane()
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun)
        {
            fun(result);
        }

        template<typename F>
        void enumerate(F& fun) const
        {
            fun(result);
        }

        bool operator == (const RegisterEventInfoOutput& t) const
        {
            return (result == t.result);
        }
    };

    struct RegisterFieldInfoOutput {
        ::rtf::maintaind::ReturnCode result;

        static bool IsPlane()
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun)
        {
            fun(result);
        }

        template<typename F>
        void enumerate(F& fun) const
        {
            fun(result);
        }

        bool operator == (const RegisterFieldInfoOutput& t) const
        {
            return (result == t.result);
        }
    };

    struct RegisterMethodInfoOutput {
        ::rtf::maintaind::ReturnCode result;

        static bool IsPlane()
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun)
        {
            fun(result);
        }

        template<typename F>
        void enumerate(F& fun) const
        {
            fun(result);
        }

        bool operator == (const RegisterMethodInfoOutput& t) const
        {
            return (result == t.result);
        }
    };
    struct RegisterNodeInfoOutput {
        ::rtf::maintaind::ReturnCode result;

        static bool IsPlane()
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun)
        {
            fun(result);
        }

        template<typename F>
        void enumerate(F& fun) const
        {
            fun(result);
        }

        bool operator == (const RegisterNodeInfoOutput& t) const
        {
            return (result == t.result);
        }
    };

    struct RegisterNodePidInfoOutput {
        ::rtf::maintaind::ReturnCode result;

        static bool IsPlane()
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun)
        {
            fun(result);
        }

        template<typename F>
        void enumerate(F& fun) const
        {
            fun(result);
        }

        bool operator == (const RegisterNodePidInfoOutput& t) const
        {
            return (result == t.result);
        }
    };

    struct UnregisterEventInfoOutput {
        ::rtf::maintaind::ReturnCode result;

        static bool IsPlane()
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun)
        {
            fun(result);
        }

        template<typename F>
        void enumerate(F& fun) const
        {
            fun(result);
        }

        bool operator == (const UnregisterEventInfoOutput& t) const
        {
            return (result == t.result);
        }
    };

    struct UnregisterFieldInfoOutput {
        ::rtf::maintaind::ReturnCode result;

        static bool IsPlane()
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun)
        {
            fun(result);
        }

        template<typename F>
        void enumerate(F& fun) const
        {
            fun(result);
        }

        bool operator == (const UnregisterFieldInfoOutput& t) const
        {
            return (result == t.result);
        }
    };

    struct UnregisterMethodInfoOutput {
        ::rtf::maintaind::ReturnCode result;

        static bool IsPlane()
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun)
        {
            fun(result);
        }

        template<typename F>
        void enumerate(F& fun) const
        {
            fun(result);
        }

        bool operator == (const UnregisterMethodInfoOutput& t) const
        {
            return (result == t.result);
        }
    };

    explicit RTFMaintaindAppServiceSkeleton(ara::com::InstanceIdentifier instanceId,
                           ara::com::MethodCallProcessingMode mode = ara::com::MethodCallProcessingMode::kEvent)
        : skeletonAdapter(std::make_unique<ara::com::internal::skeleton::SkeletonAdapter>(
	    ::rtf::maintaind::RTFMaintaindAppService::ServiceIdentifier, instanceId, mode)),
          SwitchApplicationLatency(skeletonAdapter->GetSkeleton(), events::SwitchApplicationLatencyId),
          NotifyLatencyModeHandle(skeletonAdapter->GetSkeleton(), methods::NotifyLatencyModeId),
          NotifyLatencyResultHandle(skeletonAdapter->GetSkeleton(), methods::NotifyLatencyResultId),
          RegisterEventInfoHandle(skeletonAdapter->GetSkeleton(), methods::RegisterEventInfoId),
          RegisterFieldInfoHandle(skeletonAdapter->GetSkeleton(), methods::RegisterFieldInfoId),
          RegisterMethodInfoHandle(skeletonAdapter->GetSkeleton(), methods::RegisterMethodInfoId),
          RegisterNodeInfoHandle(skeletonAdapter->GetSkeleton(), methods::RegisterNodeInfoId),
          UnregisterEventInfoHandle(skeletonAdapter->GetSkeleton(), methods::UnregisterEventInfoId),
          UnregisterFieldInfoHandle(skeletonAdapter->GetSkeleton(), methods::UnregisterFieldInfoId),
          UnregisterMethodInfoHandle(skeletonAdapter->GetSkeleton(), methods::UnregisterMethodInfoId) {
        ConstructSkeleton(mode);
    }

    RTFMaintaindAppServiceSkeleton(const RTFMaintaindAppServiceSkeleton&) = delete;
    RTFMaintaindAppServiceSkeleton& operator=(const RTFMaintaindAppServiceSkeleton&) = delete;

    RTFMaintaindAppServiceSkeleton(RTFMaintaindAppServiceSkeleton&& other) = default;
    RTFMaintaindAppServiceSkeleton& operator=(RTFMaintaindAppServiceSkeleton&& other) = default;
    virtual ~RTFMaintaindAppServiceSkeleton()
    {
        StopOfferService();
    }

    void OfferService()
    {
        skeletonAdapter->RegisterMethod(&RTFMaintaindAppServiceSkeleton::NotifyLatencyMode,
            *this, methods::NotifyLatencyModeId);
        skeletonAdapter->RegisterMethod(&RTFMaintaindAppServiceSkeleton::NotifyLatencyResult,
            *this, methods::NotifyLatencyResultId);
        skeletonAdapter->RegisterMethod(&RTFMaintaindAppServiceSkeleton::RegisterEventInfo,
            *this, methods::RegisterEventInfoId);
        skeletonAdapter->RegisterMethod(&RTFMaintaindAppServiceSkeleton::RegisterFieldInfo,
            *this, methods::RegisterFieldInfoId);
        skeletonAdapter->RegisterMethod(&RTFMaintaindAppServiceSkeleton::RegisterMethodInfo,
            *this, methods::RegisterMethodInfoId);
        skeletonAdapter->RegisterMethod(&RTFMaintaindAppServiceSkeleton::RegisterNodeInfo,
            *this, methods::RegisterNodeInfoId);
        skeletonAdapter->RegisterMethod(&RTFMaintaindAppServiceSkeleton::UnregisterEventInfo,
            *this, methods::UnregisterEventInfoId);
        skeletonAdapter->RegisterMethod(&RTFMaintaindAppServiceSkeleton::UnregisterFieldInfo,
            *this, methods::UnregisterFieldInfoId);
        skeletonAdapter->RegisterMethod(&RTFMaintaindAppServiceSkeleton::UnregisterMethodInfo,
            *this, methods::UnregisterMethodInfoId);
        skeletonAdapter->OfferService();
    }
    void StopOfferService()
    {
        skeletonAdapter->StopOfferService();
    }
    ara::core::Future<bool> ProcessNextMethodCall()
    {
        return skeletonAdapter->ProcessNextMethodCall();
    }
    bool SetMethodThreadNumber(const std::uint16_t& number, const std::uint16_t& queueSize)
    {
        return skeletonAdapter->SetMethodThreadNumber(number, queueSize);
    }

    virtual ara::core::Future<NotifyLatencyModeOutput> NotifyLatencyMode(
        const ::rtf::maintaind::LatencySwitch& latencySwitch,
        const ::rtf::maintaind::LatencyModeAckInfo& latencyAckInfo) = 0;
    virtual ara::core::Future<NotifyLatencyResultOutput> NotifyLatencyResult(
        const ::rtf::maintaind::LatencyResult& latencyResult,
        const ::rtf::maintaind::LatencyResultInfo& latencyResultInfo) = 0;
    virtual ara::core::Future<RegisterEventInfoOutput> RegisterEventInfo(
        const ::rtf::maintaind::EventRegisterInfo& eventInfo, const ::rtf::stdtype::boolean& isPub) = 0;
    virtual ara::core::Future<RegisterFieldInfoOutput> RegisterFieldInfo(
        const ::rtf::maintaind::FieldRegisterInfo& fieldInfo, const ::rtf::stdtype::boolean& isPub) = 0;
    virtual ara::core::Future<RegisterMethodInfoOutput> RegisterMethodInfo(
        const ::rtf::maintaind::MethodRegisterInfo& methodInfo, const ::rtf::stdtype::boolean& isPub) = 0;
    virtual ara::core::Future<RegisterNodePidInfoOutput> RegisterNodePidInfo(
        const ::rtf::stdtype::String& appName, const ::rtf::stdtype::int32_t& pid,
        const ::rtf::stdtype::boolean& onLine)
    {
        ara::core::Future<RegisterNodePidInfoOutput> output;
        return output;
    }
    virtual ara::core::Future<UnregisterEventInfoOutput> UnregisterEventInfo(
        const ::rtf::maintaind::EventRegisterInfo& eventInfo, const ::rtf::stdtype::boolean& isPub) = 0;
    virtual ara::core::Future<UnregisterFieldInfoOutput> UnregisterFieldInfo(
        const ::rtf::stdtype::String& fieldType, const ::rtf::stdtype::uint16_t& instanceId,
        const ::rtf::stdtype::boolean& isPub, const ::rtf::stdtype::String& appName) = 0;
    virtual ara::core::Future<UnregisterMethodInfoOutput> UnregisterMethodInfo(
        const ::rtf::maintaind::MethodRegisterInfo& methodInfo, const ::rtf::stdtype::boolean& isPub) = 0;
    virtual ara::core::Future<RegisterNodeInfoOutput> RegisterNodeInfo(
        const ::rtf::maintaind::NodeCommonRegisterInfo& nodeCommonRegisterInfo)
    {
        ara::core::Future<RegisterNodeInfoOutput> output;
        return output;
    }

    events::SwitchApplicationLatency SwitchApplicationLatency;
    methods::NotifyLatencyModeHandle NotifyLatencyModeHandle;
    methods::NotifyLatencyResultHandle NotifyLatencyResultHandle;
    methods::RegisterEventInfoHandle RegisterEventInfoHandle;
    methods::RegisterFieldInfoHandle RegisterFieldInfoHandle;
    methods::RegisterMethodInfoHandle RegisterMethodInfoHandle;
    methods::RegisterNodeInfoHandle RegisterNodeInfoHandle;
    methods::UnregisterEventInfoHandle UnregisterEventInfoHandle;
    methods::UnregisterFieldInfoHandle UnregisterFieldInfoHandle;
    methods::UnregisterMethodInfoHandle UnregisterMethodInfoHandle;
};
} // namespace skeleton
} // namespace maintaind
} // namespace rtf

#endif // RTF_MAINTAIND_RTFMAINTAINDAPPSERVICE_SKELETON_H
