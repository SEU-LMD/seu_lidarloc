/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2019-2020. All rights reserved.
 * Description: EventHandler in CM
 * Create: 2019-11-19
 */
#ifndef VRTF_VCC_DRIVER_EVENTHANDLER_H
#define VRTF_VCC_DRIVER_EVENTHANDLER_H
#include <vector>
#include <memory>
#include <unordered_map>
#include "vrtf/driver/dds/mbuf.h"
#include "vrtf/vcc/api/types.h"
#include "vrtf/vcc/utils/condition_variable.h"
#include "vrtf/vcc/utils/plog_info.h"
#include "vrtf/vcc/utils/latency_analysis.h"
#include "vrtf/vcc/utils/tlv_helper.h"
namespace vrtf {
namespace vcc {
namespace driver {
class EventCache {
public:
    EventCache(uint8_t* data, const size_t& size, Mbuf *mbufPtr, const vcc::api::types::SampleTimeInfo& takeInfo)
        : value_(data),
          size_(size),
          mbufPtr_(mbufPtr),
          takeInfo_(takeInfo) {}
    ~EventCache(void) = default;
    const uint8_t* GetData() const
    {
        return value_;
    }
    void SetData(uint8_t* data)
    {
        value_ = data;
    }
    void SetMbufPtr(Mbuf *mbufPtr)
    {
        mbufPtr_ = mbufPtr;
    }
    const Mbuf *GetMbufPtr() const
    {
        return mbufPtr_;
    }
    size_t GetSize() const
    {
        return size_;
    }
    void SetSize(const size_t& size)
    {
        size_ = size;
    }

    /**
     * @brief Get sample take info
     * @details Get sample take info
     *
     * @return size_t msg
     */
    const vrtf::vcc::api::types::SampleTimeInfo& GetSampleTimeInfo() const
    {
        return takeInfo_;
    }

    /**
     * @brief Add sample pointer this msg's uid
     * @details when receive msg, this msg will store one generate generated by plog
     *
     * @param uid msg uid for user to check delay info in plog
     */
    void SetSampleTimeInfo(const vrtf::vcc::api::types::SampleTimeInfo& info)
    {
        takeInfo_ = info;
    }
    uint8_t *value_;
private:
    size_t size_;
    Mbuf *mbufPtr_;
    vrtf::vcc::api::types::SampleTimeInfo takeInfo_;
};
using EventCacheContainer = std::vector<EventCache>;
using E2EResultContainer = std::vector<ara::com::e2e::Result>;
class EventHandler {
public:
    EventHandler() = default;
    virtual ~EventHandler() = default;
    virtual void SetSubscriptionStateChangeHandler(vrtf::vcc::api::types::SubscriptionStateChangeHandler handler) = 0;
    virtual void SendEvent(uint8_t * const data, const size_t length,
                           std::shared_ptr<vrtf::vcc::api::types::internal::SampleInfoImpl>& info) = 0;
    virtual void ReadEvent(EventCacheContainer &data, E2EResultContainer& e2eStatus, int32_t size) = 0;
    virtual const uint8_t* AllocateBuffer(const uint32_t length) = 0;
    virtual void ReturnLoan(const uint8_t *data) = 0;
    virtual void ServerReturnLoan(const uint8_t *data) = 0;
    virtual void SetReceiveHandler(vrtf::vcc::api::types::EventHandleReceiveHandler handler) = 0;
    virtual vrtf::serialize::SerializeType GetSerializeType() = 0;
    virtual std::string GetDriverName(void) = 0;
    virtual bool EnableEvent() = 0;
    virtual void UnsubscribeEvent() = 0;
    virtual std::size_t GetE2EHeaderSize() = 0;
    virtual bool IsEnableDp() = 0;
    // Dp raw data for mbuf and queue event.
    virtual bool IsDpRawData() = 0;
};
}
}
}

#endif
